// @author Roman Manevich.
package heap.ast;

import java.io.*;
import java.util.*;

import heap.ast.Token;

import java_cup.runtime.Symbol;

/** A parser for heap synthesis problems.
 * @author Roman Manevich
 */
parser code {:
   private HeapLexer lexer;
    
   /**
    * Parses the file with the given name and returns the corresponding abstract syntax tree.
    */
   public ASTProblem parseFile(String file) throws SyntaxError, FileNotFoundException, Exception {
	lexer = new HeapLexer(new FileReader(file));
	HeapParser parser = new HeapParser(lexer);
	Symbol root = parser.parse();
	return (ASTProblem) root.value;
  }
  	
  @Override	
  public void report_fatal_error(String message, Object info) throws SyntaxError {
    Token token = (Token) info;
    throw new SyntaxError("Syntax error at " + token.line + ":" + token.column + " on " + token.text);
  }
:}

terminal TYPE, VAR, NULL, EXAMPLE, MUT,
         COMMA, DOT, EQ, AND, COLON, ARROW, LP, RP, LCB, RCB;
		
terminal Integer INT_VAL; 
terminal String ID;

// Unfortunately, CUP doesn't recognize generic types.
// Therefore, all lists are untyped.
		
nonterminal ASTProblem problem;
nonterminal List elemList; // <AST>
nonterminal AST elem;
nonterminal ASTRefType typeDef;
nonterminal List fields; // <ASTField>
nonterminal List optionalFields; // <ASTField>
nonterminal ASTField field;
nonterminal ASTFun funDef;
nonterminal List inputArgs; // <ASTVar>
nonterminal List outputArgs; // <ASTVar>
nonterminal List optionalInputArgs; // <ASTVar>
nonterminal List optionalOutputArgs; // <ASTVar>
nonterminal List temps; // <ASTVar>
nonterminal List optionalTemps; // <ASTVar>
nonterminal ASTVar temp;
nonterminal ASTVar var;
nonterminal List examples; // <ASTExample>
nonterminal List optionalExamples; // <ASTExample>
nonterminal ASTExample example;
nonterminal ASTStore store;
nonterminal AST storeVal;
nonterminal List heapElems; // <ASTfieldVal>
nonterminal List optionalHeapElems; // <ASTfieldVal>

///////////////////////////////////////////////////
// Productions

problem ::= elemList:elements
	{: RESULT = new ASTProblem(elements); :}
;

elemList ::= elem:e
	{: RESULT = new ArrayList<AST>();
	   RESULT.add(e);
    :}
	| elemList:prefix elem:e
	{: prefix.add(e);
	   RESULT = prefix;
	:}
;

elem ::= typeDef:e
	{: RESULT = e; :}
	| funDef:e
	{: RESULT = e; :}
;

typeDef ::= TYPE ID:name LCB optionalFields:fields RCB
	{: RESULT = new ASTRefType(name, fields); :}
;

optionalFields ::= 
	{: RESULT = new ArrayList<ASTField>(); :}
	| fields:fields
	{: RESULT = fields; :}
;

fields ::= field:f
	{: RESULT = new ArrayList<ASTField>();
	   RESULT.add(f);
	:}
	| fields:prefix field:f
	{: prefix.add(f);
	   RESULT = prefix;
	:}
;

field ::= ID:name COLON ID:type
	{: RESULT = new ASTField(name, type); :}
;

funDef ::= ID:name LP optionalInputArgs:inargs RP ARROW LP optionalOutputArgs:outargs RP LCB optionalTemps:temps optionalExamples:examples RCB
	{: RESULT = new ASTFun(name, inargs, outargs, temps, examples); :}
;

optionalInputArgs ::= 
	{: RESULT = new ArrayList<ASTVar>(); :}
	| inputArgs:args
	{: RESULT = args; :}
;

optionalOutputArgs ::= 
	{: RESULT = new ArrayList<ASTVar>(); :}
	| outputArgs:args
	{: RESULT = args; :}
;

inputArgs ::= var:a
	{: a.readonly = true;
	   RESULT = new ArrayList<ASTVar>();
	   RESULT.add(a);
	:}
	| MUT var:a
	{: a.readonly = false;
	   RESULT = new ArrayList<ASTVar>();
	   RESULT.add(a);
	:}
	| inputArgs:prefix COMMA var:a
	{: prefix.add(a);
	   RESULT = prefix;
	:}
;

outputArgs ::= var:a
	{: a.readonly = false;
	   RESULT = new ArrayList<ASTVar>();
	   RESULT.add(a);
	:}
	| outputArgs:prefix COMMA var:a
	{: prefix.add(a);
	   RESULT = prefix;
	:}
;

var ::= ID:name COLON ID:type
	{: RESULT = new ASTVar(name, type);
	   RESULT.readonly = true;
	:}
;

optionalTemps ::=  
	{: RESULT = new ArrayList<ASTVar>(); :}
	| temps:temps
	{: RESULT = temps; :}
;

temps ::= temp:t
	{: RESULT = new ArrayList<ASTVar>();
	   RESULT.add(t);
	:}
	| temps:prefix COMMA temp:t
	{: prefix.add(t);
	   RESULT = prefix;
	:}
;

temp ::= VAR var:v
	{: RESULT = v;
	   v.readonly = false;
	:}
;

optionalExamples ::=
	{: RESULT = new ArrayList<ASTExample>(); :}
	| examples:examples
	{: RESULT = examples; :}
;

examples ::= example:e
	{: RESULT = new ArrayList<ASTExample>();
	   RESULT.add(e);
	:}
	| examples:prefix example:e
	{: prefix.add(e);
	   RESULT = prefix;
	:} 
;

example ::= EXAMPLE LCB store:input ARROW store:goal RCB
	{: RESULT = new ASTExample(input, goal); :}
;

store ::= optionalHeapElems:elements
	{: RESULT = new ASTStore(elements); :}
;

optionalHeapElems ::= 
	{: RESULT = new ArrayList<ASTVal>(); :}
	| heapElems:heapElems
	{: RESULT = heapElems; :}
;

heapElems ::= storeVal:v
	{: RESULT = new ArrayList<ASTVal>();
	   RESULT.add(v);
	:}
	| heapElems:prefix AND storeVal:v
	{: prefix.add(v);
	   RESULT = prefix;
	:} 
;

storeVal ::= ID:var EQ ID:val
	{: RESULT = new ASTRefVarVal(var, val); :}
	| ID:var EQ NULL
	{: RESULT = new ASTRefVarVal(var, AST.NULL_VAL_NAME); :}
	| ID:var EQ INT_VAL:val
	{: RESULT = new ASTIntVarVal(var, val); :}
	| ID:src DOT ID:field EQ ID:dst
	{: RESULT = new ASTRefFieldVal(field, src, dst); :}
	| ID:src DOT ID:field EQ NULL
	{: RESULT = new ASTRefFieldVal(field, src, AST.NULL_VAL_NAME); :}
	| ID:src DOT ID:field EQ INT_VAL:val
	{: RESULT = new ASTIntFieldVal(field, src, val); :}
;
